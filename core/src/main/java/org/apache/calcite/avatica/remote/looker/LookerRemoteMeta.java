/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to you under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.calcite.avatica.remote.looker;

import org.apache.calcite.avatica.AvaticaConnection;
import org.apache.calcite.avatica.AvaticaStatement;
import org.apache.calcite.avatica.Meta;
import org.apache.calcite.avatica.MissingResultsException;
import org.apache.calcite.avatica.NoSuchStatementException;
import org.apache.calcite.avatica.QueryState;
import org.apache.calcite.avatica.remote.JsonService;
import org.apache.calcite.avatica.remote.RemoteMeta;
import org.apache.calcite.avatica.remote.Service;
import org.apache.calcite.avatica.remote.Service.PrepareAndExecuteRequest;
import org.apache.calcite.avatica.remote.Service.PrepareRequest;
import org.apache.calcite.avatica.remote.TypedValue;

import com.looker.rtl.AuthSession;
import com.looker.rtl.Transport;
import com.looker.sdk.LookerSDK;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.sql.SQLException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.stream.Collectors;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

/**
 * Implementation of Meta that works in tandem with {@link LookerRemoteService} to stream results
 * from the Looker SDK.
 */
public class LookerRemoteMeta extends RemoteMeta implements Meta {

  private final LookerRemoteService lookerService;

  public LookerRemoteMeta(AvaticaConnection connection, Service service) {
    super(connection, service);
    // this class _must_ be backed by a LookerRemoteService
    assert LookerRemoteService.class.isAssignableFrom(service.getClass());
    lookerService = (LookerRemoteService) service;
  }

  /**
   * Default queue size. Could probably be more or less. 10 chosen for now.
   */
  private static final int DEFAULT_FRAME_QUEUE_SIZE = 10;

  /**
   * Returns authenticated LookerSDK from LookerRemoteService.
   */
  private LookerSDK getSdk() {
    return lookerService.sdk;
  }

  /**
   * A single meta can have multiple running statements. This map keeps track of
   * {@code FrameEnvelopes}s that belong to a running statement. See {@link #prepareStreamingThread}
   * for more details.
   */
  final ConcurrentMap<Integer, BlockingQueue<LookerFrameEnvelope>> stmtQueueMap =
      new ConcurrentHashMap<>();

  /**
   * An initially empty frame specific to Looker result sets. {@link #sqlInterfaceQueryId} is used
   * to begin a streaming query.
   */
  static class LookerFrame extends Frame {

    /**
     * A unique ID for the current SQL statement to run. Prepared and set during
     * {@link LookerRemoteService#apply(PrepareAndExecuteRequest)} or
     * {@link LookerRemoteService#apply(PrepareRequest)}. This is distinct from a statement ID.
     * Multiple statements may execute the same query ID.
     */
    public final Long sqlInterfaceQueryId;

    LookerFrame(long offset, boolean done, Iterable<Object> rows, Long statementId) {
      super(offset, done, rows);
      this.sqlInterfaceQueryId = statementId;
    }

    /**
     * Creates a {@code LookerFrame} for the query id.
     *
     * @param sqlInterfaceQueryId id for the prepared statement generated by a Looker instance.
     * @return the {@code firstFrame} for the result set.
     */
    public static final LookerFrame create(Long sqlInterfaceQueryId) {
      return new LookerFrame(0, false, Collections.emptyList(), sqlInterfaceQueryId);
    }
  }

  /**
   * Helper to disable any SSL and hostname verification when `verifySSL` is false.
   */
  private void trustAllHosts(HttpsURLConnection connection) {
    // Create a trust manager that does not validate certificate chains
    TrustManager[] trustAllCerts = new TrustManager[]{
        new X509TrustManager() {
          public java.security.cert.X509Certificate[] getAcceptedIssuers() {
            return null;
          }

          public void checkClientTrusted(java.security.cert.X509Certificate[] certs,
              String authType) {
          }

          public void checkServerTrusted(java.security.cert.X509Certificate[] certs,
              String authType) {
          }
        }
    };
    // Create all-trusting host name verifier
    HostnameVerifier trustAllHostNames = (hostname, session) -> true;
    try {
      SSLContext sc = SSLContext.getInstance("SSL");
      sc.init(null, trustAllCerts, new java.security.SecureRandom());
      connection.setSSLSocketFactory(sc.getSocketFactory());
      connection.setHostnameVerifier(trustAllHostNames);
    } catch (NoSuchAlgorithmException | KeyManagementException e) {
      throw new RuntimeException(e);
    }
  }

  /**
   * A regrettable necessity. The Kotlin SDK relies on an outdated Ktor HTTP client based on Kotlin
   * Coroutines which are difficult to work with in Java. Here we make a HTTP client to handle the
   * request and input stream ourselves. This adds complexity that would normally be handled by the
   * SDK. We should revisit this once the SDK has built-in streams.
   *
   * TODO https://github.com/looker-open-source/sdk-codegen/issues/1341:
   *  Add streaming support to the Kotlin SDK.
   */
  protected InputStream makeRunQueryRequest(String url) throws IOException, SQLException {
    AuthSession authSession = getSdk().getAuthSession();
    Transport sdkTransport = authSession.getTransport();

    // makes a proper URL from the API endpoint path as the SDK would.
    String endpoint = sdkTransport.makeUrl(url, Collections.emptyMap(), null);
    URL httpsUrl = new URL(endpoint);
    HttpsURLConnection connection = (HttpsURLConnection) httpsUrl.openConnection();

    // WARNING: You should only set `verifySSL=false` for local/dev instances!!
    if (!sdkTransport.getOptions().getVerifySSL()) {
      trustAllHosts(connection);
    }

    // convert timeout seconds to milliseconds
    int timeout = sdkTransport.getOptions().getTimeout() * 1000;
    connection.setReadTimeout(timeout);

    connection.setRequestMethod("GET");
    connection.setRequestProperty("Accept", "application/json");
    connection.setDoOutput(true);

    // set the auth header as the SDK would
    connection.setRequestProperty("Authorization",
        "token " + authSession.getAuthToken().getAccessToken());

    // copy the headers from the authenticated SDK.
    authSession.getApiSettings().getHeaders()
        .forEach((header, value) -> connection.setRequestProperty(header, value));

    int responseCode = connection.getResponseCode();
    if (responseCode == 200) {
      // return the input stream to parse from.
      return connection.getInputStream();
    } else {
      InputStream errorIn = connection.getErrorStream();
      String errorMessage =
          new BufferedReader(new InputStreamReader(errorIn, StandardCharsets.UTF_8))
              .lines()
              .collect(Collectors.joining("\n"));
      HashMap<String, String> errorMap = JsonService.MAPPER.readValue(errorMessage, HashMap.class);
      throw new SQLException("Looker generated SQL failed to execute. "
          + errorMap.getOrDefault("message", ""));
    }
  }

  /**
   * Prepares a thread to stream a query response into a series of {@link LookerFrameEnvelope}s.
   */
  protected Thread prepareStreamingThread(String baseUrl, Signature signature, int fetchSize,
      BlockingQueue<LookerFrameEnvelope> frameQueue) throws IOException, SQLException {

    InputStream in = makeRunQueryRequest(baseUrl);
    LookerResponseParser parser = new LookerResponseParser(frameQueue);

    return new Thread(() -> parser.parseStream(in, signature, fetchSize));
  }

  @Override
  public Frame fetch(final StatementHandle h, final long offset, final int fetchMaxRowCount)
      throws NoSuchStatementException, MissingResultsException {
    // If this statement was initiated as a LookerFrame then it will have an entry in the queue map
    if (stmtQueueMap.containsKey(h.id)) {
      try {
        BlockingQueue<LookerFrameEnvelope> queue = stmtQueueMap.get(h.id);

        // `take` blocks until there is an entry in the queue
        LookerFrameEnvelope nextEnvelope = queue.take();

        // remove the statement from the map if it has an exception, or it is the last frame
        if (nextEnvelope.hasException()) {
          stmtQueueMap.remove(h.id);
          throw new RuntimeException(nextEnvelope.getException());
        } else if (nextEnvelope.getFrame().done) {
          stmtQueueMap.remove(h.id);
        }
        return nextEnvelope.getFrame();
      } catch (InterruptedException e) {
        throw new RuntimeException(e);
      }
    }
    // not a streaming query - default to RemoteMeta behavior
    return super.fetch(h, offset, fetchMaxRowCount);
  }

  /**
   * Creates a streaming iterable that parses a JSON {@link InputStream} into a series of
   * {@link LookerFrameEnvelope}s.
   */
  @Override
  public Iterable<Object> createIterable(StatementHandle h, QueryState state, Signature signature,
      List<TypedValue> parameters, Frame firstFrame) {
    // If this a LookerFrame, then we must be targeting the sql_interface APIs
    if (LookerFrame.class.isAssignableFrom(firstFrame.getClass())) {
      try {
        // generate the endpoint URL to begin the request
        LookerFrame lookerFrame = (LookerFrame) firstFrame;
        String url = LookerSdkFactory.queryEndpoint(lookerFrame.sqlInterfaceQueryId);

        // grab the statement
        AvaticaStatement stmt = connection.statementMap.get(h.id);
        if (null == stmt) {
          throw new NoSuchStatementException(h);
        }

        // setup queue to place complete frames
        BlockingQueue<LookerFrameEnvelope> frameQueue = new ArrayBlockingQueue(
            DEFAULT_FRAME_QUEUE_SIZE);

        // update map so this statement is associated with a queue
        stmtQueueMap.put(stmt.handle.id, frameQueue);

        // init and start a new thread to stream from a Looker instance and populate the frameQueue
        prepareStreamingThread(url, signature, stmt.getFetchSize(), frameQueue).start();
      } catch (SQLException | NoSuchStatementException | IOException e) {
        throw new RuntimeException(e);
      }
    }
    // always return a FetchIterable - we'll check in LookerRemoteMeta#fetch for any enqueued Frames
    return super.createIterable(h, state, signature, parameters, firstFrame);
  }
}
